# Instructions

During you interaction with the user, if you find anything reusable in this project (e.g. version of a library, model name), especially about a fix to a mistake you made or a correction you received, you should take note in the `Lessons` section in the `.cursorrules` file so you will not make the same mistake again.

You should also use the `.cursorrules` file as a scratchpad to organize your thoughts. Especially when you receive a new task, you should first review the content of the scratchpad, clear old different task if necessary, first explain the task, and plan the steps you need to take to complete the task. You can use todo markers to indicate the progress, e.g.
[X] Task 1
[ ] Task 2

Also update the progress of the task in the Scratchpad when you finish a subtask.
Especially when you finished a milestone, it will help to improve your depth of task accomplishment to use the scratchpad to reflect and plan.
The goal is to help you maintain a big picture as well as the progress of the task. Always refer to the Scratchpad when you plan the next step.

# MCP Server Tools Usage

## Strategic Tool Selection

- **Sequential Thinking:**
  - Use for multi-step operations requiring careful planning.
  - Maintain operational context to enable course correction.
  - Begin with a higher number of total thoughts (e.g. 8â€“12) for complex tasks.
  - Use branching to explore alternative approaches and mark revisions when needed.
  - Set `needsMoreThoughts=true` when new complexities arise.

- **Web Research (via Brave Search):**
  - Always conduct initial broad searches, then follow with detailed research.
  - Validate technical approaches, error handling strategies, and best practices.
  - Cross-reference multiple reputable sources before implementation.

- **Puppeteer Operations:**
  - Use for intricate web interactions and testing.
  - Implement chained operations with robust error handling, waits, and retries.
  - Optimise memory by closing pages when done and reusing browser instances.

- **Server Memory (Knowledge Graph):**
  - Maintain complex relationships and operational context.
  - Create entities for major components and concepts.
  - Map dependencies and document architectural decisions.
  - Regularly clean up obsolete entities and update relationships.

### Sequential Thinking
- Use for operations requiring multiple steps
- Essential for maintaining operational context
- Helps break down large changes into manageable chunks
- Enables course correction and revision of approach
- Key usage patterns:
  * Start with higher total_thoughts for complex tasks (8-12)
  * Use branching for exploring alternative approaches
  * Mark revisions when changing previous decisions
  * Set needsMoreThoughts=true when discovering new complexity
  * Use as tactical memory during long operations

### Web Research (Brave Search)
- Always search before implementing complex features
- Research patterns:
  * Start with broad concept search
  * Follow up with specific implementation details
  * Look for recent discussions and solutions
  * Cross-reference multiple sources
  * Use for validating approach before major changes
- Key usage:
  * Technical implementation patterns
  * Error handling strategies
  * Best practices validation
  * Community solutions to similar problems

### Puppeteer Operations
- Use for complex web interactions and testing
- Strategic patterns:
  * Chain operations with proper error handling
  * Use screenshots for validation points
  * Implement waits and retries for stability
  * Maintain session context across operations
- Memory management:
  * Close pages when done
  * Reuse browser instances when possible
  * Clear large objects after operations
  * Monitor memory usage in long sessions

## Operational Guidelines

### For Moderate Changes (30-100 lines):
1. Start with sequential thinking (5-8 thoughts)
2. Research similar implementations
3. Plan key validation points
4. Execute with regular state checks

### For Large Changes (100+ lines):
1. Begin with comprehensive sequential thinking (10+ thoughts)
2. Extensive research phase
3. Break into sub-operations
4. Regular validation checkpoints
5. Maintain operational memory through scratchpad


# Lessons

# Scratchpad

## Analysis of QuickEmailVerification Node Caching Implementation

### Current Implementation

[X] Explored the codebase and identified key files related to caching
[X] Analyzed how the Keyv library is used for caching email verification responses
[X] Evaluated the caching configuration and behavior
[X] Researched Keyv library capabilities and limitations
[X] Investigated n8n execution model and its implications for caching

### Key Findings

1. **Implementation Details**:
   - Uses Keyv library with in-memory storage
   - Cache is implemented as a static property of the QuickEmailVerification class
   - Default TTL is 30 days, configurable through credentials
   - Cache key is the email address
   - Caches only successful verification results
   - Adds verification timestamp to cached results

2. **Limitations and Potential Issues**:
   - In multi-process n8n deployments, each process has its own isolated cache
   - No cache size limits, potentially leading to memory growth
   - Cache is completely reinitialized when TTL changes, losing all data
   - No mechanism for manual cache invalidation or clearing
   - Minimal error handling for cache operations
   - No cache statistics or monitoring capabilities

3. **Overall Assessment**:
   - The implementation is sound for basic caching needs in a single-process environment
   - No major bugs or critical flaws were identified
   - The issues are primarily limitations or areas for improvement rather than bugs
   - Efficiency and consistency issues may arise in multi-process deployments

### Potential Improvements for Expansion

1. **Cross-Process Caching**:
   - Implement Redis or another shared backend for multi-process deployments
   - Configure Keyv to use the shared backend when available

2. **Memory Management**:
   - Add cache size limits to prevent memory growth
   - Implement LRU (Least Recently Used) eviction policy

3. **Cache Control**:
   - Add methods for clearing the entire cache or specific entries
   - Preserve cache when TTL changes instead of reinitializing
   - Add configuration for cache behavior on startup

4. **Enhanced Features**:
   - Add cache statistics tracking (hits, misses, etc.)
   - Support more complex cache keys beyond email address
   - Implement cache prefetching for frequently accessed data
   - Consider multi-tiered caching with different TTLs

5. **Robustness**:
   - Improve error handling for cache operations
   - Add logging for cache events and errors
   - Implement cache health checks and recovery mechanisms

### Next Steps

[ ] Prioritize improvements based on their impact and implementation complexity
[ ] Develop a detailed implementation plan for the selected improvements
[ ] Consider backward compatibility when designing the expanded caching solution
[ ] Plan for testing the enhanced caching implementation

